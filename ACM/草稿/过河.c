#include <stdio.h>
/**********************************************************************
*   解题思路；
*使用2维数组表示棋盘，通过 0/1 标记 可行/不可行 点位。
*马的位置 [m][n] -->不可行点位为[m - 1/2][n - 2/1] 与[m][n] 排除点位
*某一点的到达路径等于 前两点可达路径之和.
*通过设定[0][0]--->[1][0]的初始值 1 开始历遍
*******************************************************************/
long long f_1[21][21];
long long f_2[21][21]={0};
int m,n,a,b;
void ma_dian (int x,int y)
{
    //马的点位
    f_1[x][y] = 1;
    f_1[x - 1][y + 2] = 1;
    f_1[x - 1][y - 2] = 1;
    f_1[x + 1][y - 2] = 1;
    f_1[x + 1][y + 2] = 1;
    f_1[x + 2][y - 1] = 1;
    f_1[x + 2][y + 1] = 1;
    f_1[x - 2][y - 1] = 1;
    f_1[x - 2][y + 1] = 1;
}
int main()
{
    scanf("%d %d %d %d",&m,&n,&a,&b);
    //a,b 为马 m/n为边界(终点)
    f_2[1][0] = 1;//chushi[0][0] --> [1][0]的条数
    ma_dian(a,b);
    if (m == 0 || n==0)
    {   printf("1"); }
    else 
    {
        for (int i = 1;i <= n + 1;i++)
        {
            for (int j = 1;j <= m + 1;j++)
            {
                f_2[i][j] = f_2[i - 1][j] + f_2[i][j - 1];
                if (f_1[i - 1][j - 1])
                {   f_2[i][j] = 0;  }
            }
        }
            printf("%ld\n",f_2[m+1][n+1]);
    }

}